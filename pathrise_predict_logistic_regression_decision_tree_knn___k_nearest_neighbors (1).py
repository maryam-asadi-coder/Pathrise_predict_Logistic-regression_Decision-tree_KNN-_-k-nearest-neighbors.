# -*- coding: utf-8 -*-
"""Pathrise_predict_Logistic regression_Decision tree_KNN _ k nearest neighbors.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d4lbW9YLX41VrFjKWm4m01UE_jzLqqLq

![image.png](data:image/png;base64,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AAIgAAIg4IAABL8DiEgCBEAABEAABEAABEAABEAABEAABGIjAMEfm0dgDwiAAAiAAAiAAAiAAAiAAAiAAAg4IADB7wAikgABEAABEAABEAABEAABEAABEACB2AhA8MfmEdgDAiAAAiAAAiAAAiAAAiAAAiAAAg4IQPA7gIgkQAAEQAAEQAAEQAAEQAAEQAAEQCA2AhD8sXkE9oAACIAACIAACIAACIAACIAACICAAwIQ/A4gIgkQAAEQAAEQAAEQAAEQAAEQAAEQiI0ABH9sHoE9IAACIAACIAACIAACIAACIAACIOCAAAS/A4hIAgRAAARAAARAAARAAARAAARAAARiIwDBH5tHYA8IgAAIgAAIgAAIgAAIgAAIgAAIOCAAwe8AIpIAARAAARAAARAAARAAARAAARAAgdgIQPDH5hHYAwIgAAIgAAIgAAIgAAIgAAIgAAIOCEDwO4CIJEAABEAABEAABEAABEAABEAABEAgNgIQ/LF5BPaAAAiAAAiAAAiAAAiAAAiAAAiAgAMCEPwOICIJEAABEAABEAABEAABEAABEAABEIiNAAR/bB6BPSAAAiAAAiAAAiAAAiAAAiAAAiDggAAEvwOISAIEQAAEQAAEQAAEQAAEQAAEQAAEYiMAwR+bR2APCIAACIAACIAACIAACIAACIAACDggAMHvACKSAAEQAAEQAAEQAAEQAAEQAAEQAIHYCEDwx+YR2AMCIAACIAACIAACIAACIAACIAACDghA8DuAiCRAAARAAARAAARAAARAAARAAARAIDYCEPyxeQT2gAAIgAAIgAAIgAAIgAAIgAAIgIADAhD8DiAiCRAAARAAARAAARAAARAAARAAARCIjQAEf2wegT0gAAIgAAIgAAIgAAIgAAIgAAIg4IAABL8DiEgCBEAABEAABEAABEAABEAABEAABGIjAMEfm0dgDwiAAAiAAAiAAAiAAAiAAAiAAAg4IADB7wAikgABEAABEAABEAABEAABEAABEACB2AhA8MfmEdgDAiAAAiAAAiAAAiAAAiAAAiAAAg4IQPA7gIgkQAAEQAAEQAAEQAAEQAAEQAAEQCA2AhD8sXkE9oAACIAACIAACIAACIAACIAACICAAwIQ/A4gIgkQAAEQAAEQAAEQAAEQAAEQAAEQiI0ABH9sHoE9IAACIAACIAACIAACIAACIAACIOCAAAS/A4hIAgRAAARAAARAAARAAARAAARAAARiIwDBH5tHYA8IgAAIgAAIgAAIgAAIgAAIgAAIOCAAwe8AIpIAARAAARAAARAAARAAARAAARAAgdgIQPDH5hHYAwIgAAIgAAIgAAIgAAIgAAIgAAIOCEDwO4CIJEAABEAABEAABEAABEAABEAABEAgNgIQ/LF5BPaAAAiAAAiAAAiAAAiAAAiAAAiAgAMCEPwOICIJEAABEAABEAABEAABEAABEAABEIiNAAR/bB6BPSAAAiAAAiAAAiAAAiAAAiAAAiDggAAEvwOISAIEQAAEQAAEQAAEQAAEQAAEQAAEYiMAwR+bR2APCIAACIAACIAACIAACIAACIAACDggoA33FNlg/9t0yW0dFANJgAAIgAAIgAAIgAAIgAAIgAAIgAAIDBMQwR/y/5ajL/7DYXvwGQRAAARAAARAAARAAARAAARAAARAwAEBRbw75H8HRUASIAACIAACIAACIAACIAACIAACIFALAv8ff75qXfqkIR4AAAAASUVORK5CYII=)
# Pathrise is an online program that provides 1-on-1 mentorship, training, and advice to help job seekers get the best possible jobs in tech. Every two weeks, Pathrise welcomes a new cohort of fellows. If a candidate is interested in joining our program and successfully passes all stages of our admission process, they receive an offer to join Pathrise and become a fellow.
On average, for fellows who stay with us after their free trial period, it takes about 4 months to receive a final job offer. However, there is a lot of variation in fellows' outcomes. Being able to predict how fast every single fellow is going to find a job is crucial for our business. In this exercise we provide you with a sample of information we collected from our fellows from the moment they joined our program.

The main goal of your analysis is to derive insights around if a fellow will ultimately be placed at a company and how long until a placement can be expected.

Hi there, my name is Maryam. I would be delighted if you could review my code and provide your feedback.

# Objectives
Perform exploratory Data Analysis and determine Training Labels

create a column for the class Standardize the data Split into training data and test data -Find best Hyperparameter for SVM, Classification Trees and Logistic Regression

Find the method performs best using test data

# Import Libraries and Define Auxiliary Functions
We will import the following libraries for the lab
"""

# This library is a powerhouse for data manipulation and analysis. It allows you to read and write data from various sources (CSV, Excel, databases), clean and transform data, perform calculations, and explore data through various functionalities
import pandas as pd
# NumPy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays
import numpy as np
# Matplotlib is a plotting library for python and pyplot gives us a MatLab like plotting framework. We will use this in our plotter function to plot data.
import matplotlib.pyplot as plt
#Seaborn is a Python data visualization library based on matplotlib. It provides a high-level interface for drawing attractive and informative statistical graphics
import seaborn as sns
# Preprocessing allows us to standarsize our data
from sklearn import preprocessing
# Allows us to split our data into training and testing data
from sklearn.model_selection import train_test_split
# Allows us to test parameters of classification algorithms and find the best one
from sklearn.model_selection import GridSearchCV
# Logistic Regression classification algorithm
from sklearn.linear_model import LogisticRegression
# Support Vector Machine classification algorithm
from sklearn.svm import SVC
# Decision Tree classification algorithm
from sklearn.tree import DecisionTreeClassifier
# K Nearest Neighbors classification algorithm
from sklearn.neighbors import KNeighborsClassifier

"""
This function is to plot the confusion matrix."""

def plot_confusion_matrix(y,y_predict):
    "this function plots the confusion matrix"
    from sklearn.metrics import confusion_matrix
#It starts by importing the confusion_matrix function from sklearn.metrics. This function calculates the confusion matrix based on the provided true labels (y) and predicted labels (y_predict).
    cm = confusion_matrix(y, y_predict)
#The code then calculates the confusion matrix using cm = confusion_matrix(y, y_predict). The confusion matrix is a table that shows how many data points were correctly classified (e.g., predicted as "placed" and actually belonged to "placed") and how many were misclassified (e.g., predicted as "placed" but actually belonged to "did not place").
    ax= plt.subplot()
#It creates a subplot using plt.subplot() and then uses sns.heatmap from Seaborn to visualize the confusion matrix
#The annot=True argument in sns.heatmap ensures that the numerical values in each cell of the matrix are displayed on the heatmap.
    sns.heatmap(cm, annot=True, ax = ax); #annot=True to annotate cells
    ax.set_xlabel('Predicted labels')
    ax.set_ylabel('True labels')
    ax.set_title('Confusion Matrix');
    #This line sets custom labels for the x-axis ticks. It replaces the default numerical labels with "did not place" and "placed", which are likely the categories in your data.
    #This line sets custom labels for the y-axis ticks, mirroring the x-axis customization.
    ax.xaxis.set_ticklabels(['did not place', 'placed']); ax.yaxis.set_ticklabels(['did not place', 'placed'])
    plt.show()

from google.colab import files

uploaded = files.upload()

df= pd.read_csv('Pathrise_processedData.csv')

# X: This variable stores a new DataFrame containing all columns except "placed".
# Y: This variable stores a Pandas Series containing the values from the "placed" column.
X= df.drop('placed', axis=1)
Y= df['placed']
#In essence, this code separates the features (all columns except "placed") from the target variable ("placed") in preparation for further analysis tasks like machine learning or modeling. The features stored in X can be used as input for models, while the target variable in Y can be used as the predicted outcome.

y=df['placed'].to_numpy()
y

"""
Standardize the data in X then reassign it to the variable X using the transform provided below."""

#students get this
#Data standardization aims to transform features (columns) in a DataFrame to have a mean of 0 and a standard deviation of 1. This helps machine learning models converge faster and often improves their performance.
#Common libraries like scikit-learn offer functions like StandardScaler to achieve standardization. You'd typically apply it to df_x after creating it.
transform = preprocessing.StandardScaler()

#creates a new DataFrame named df_x by removing a column named 'placed' from the existing DataFrame df.
df_x=df.drop('placed', axis=1)

#fit: The fit method of the StandardScaler object (transform) estimates the mean and standard deviation of each feature in the DataFrame df_x. These statistics are used for standardization.
#transform: The transform method then applies the standardization using the calculated mean and standard deviation. It subtracts the mean from each feature value and then divides by the standard deviation. The result is stored in the variable x.
x = transform.fit_transform(df_x)

"""Use the function train_test_split to split the data X and Y into training and test data. Set the parameter test_size to 0.2 and random_state to 2. The training data and test data should be assigned to the following labels
X_train, X_test, Y_train, Y_test
"""

#This argument specifies the proportion of the data to be included in the testing set. In this case, 20% of the data will be allocated to the testing set, and the remaining 80% will be used for training.
#This argument helps ensure reproducibility of the results. By setting a specific value for random_state, you guarantee that the splitting process will always generate the same division of data into training and testing sets whenever you run the code. This is useful for comparing different machine learning models or running the same code multiple times.
X_train, X_test, Y_train, Y_test= train_test_split(X, Y, test_size=0.2, random_state=2)

"""Create a logistic regression object then create a GridSearchCV object logreg_cv with cv = 10. Fit the object to find the best parameters from the dictionary parameters.

# Logistic regression
"""

#his line instantiates a LogisticRegression object and assigns it to the variable Lr. This object represents a logistic regression classifier that you can use to train a model for binary or multiclass classification tasks.
Lr= LogisticRegression()

#This dictionary defines the hyperparameters you want to test for the logistic regression model
#'C': This parameter controls the regularization strength. Lower values of C mean weaker regularization and might lead to overfitting, while higher values mean stronger regularization and might lead to underfitting. The values you've chosen are [0.01, 0.1, 1], which is a good starting point for grid search.
#'penalty': This parameter specifies the type of regularization to use. You've set it to 'l2', which is L2 regularization. L2 regularization penalizes the model for having large coefficients, encouraging simpler models that might generalize better.
#'solver': This parameter specifies the algorithm used to fit the logistic regression model. You've set it to 'lbfgs', which is the L-BFGS solver. This is a good choice for many logistic regression problems.
#t's important to note that the specific values provided for the 'C' parameter (0.01, 0.1, 1) might not always be the most suitable for every Ridge regression model. The optimal choice of C depends on various factors, including:
#Data Size: Larger datasets may require larger C values.
#Noise Level: Noisy data may necessitate smaller C values to prevent overfitting.
#Feature Scaling: If feature values have different scales, it's recommended to standardize them before training the model.
parametersLr ={'C':[0.01,0.1,1],
             'penalty':['l2'],
             'solver':['lbfgs']}

#cross-validation folds(CV)
logreg_cv= GridSearchCV(Lr, parametersLr, cv=10)

logreg_cv.fit(X_train, Y_train)

#his code is used to print the best hyperparameter values and the resulting accuracy score obtained from GridSearchCV
#You can also use this code to print the best hyperparameter values and accuracy score for each model during the grid search.
#To do this, you can use a for loop to iterate over the results of GridSearchCV.
#C: This is the regularization parameter that controls the amount of regularization applied to the model.
#penalty: This parameter specifies the type of regularization to use: L1 (Lasso) or L2 (Ridge).
#solver: This parameter specifies the optimization algorithm to use for training the model.
print("tuned hpyerparameters :(best parameters) ",logreg_cv.best_params_)
print("accuracy :",logreg_cv.best_score_)

"""# Calculate the accuracy on the test data using the method score:"""

logreg_cv.score(X_test, Y_test)
#The output of the code is the score of the logistic regression model on the test dataset. In this case, the score is 0.6221590909090909, indicating that the model has 62.21% accuracy in predicting the labels for new samples.

#yhatlog=logreg_cv.predict(X_test), employs the predict() method of the GridSearchCV object to generate predictions for the test samples (X_test). The predictions are stored in the yhatlog array.
#plot_confusion_matrix(Y_test,yhatlog), utilizes the plot_confusion_matrix() function to visualize the model's performance using a confusion matrix. This matrix compares the actual labels (Y_test) to the predicted labels (yhatlog) and provides insights into the model's strengths and weaknesses.
yhatlog=logreg_cv.predict(X_test)
plot_confusion_matrix(Y_test,yhatlog)

"""Create a support vector machine object then create a GridSearchCV object svm_cv with cv - 10. Fit the object to find the best parameters from the dictionary parameters.

# Support vector machine
"""

#import svm: This line imports the SVM module from Scikit-learn.
#svm = SVC(): This line creates an instance of the SVC class and assigns it to the variable svm. This variable now holds the SVM classifier object.
#The SVC object can be used to train a model on a dataset and then make predictions on new data. To train the model, you would call the fit() method, passing in the training data and target labels. To make predictions, you would call the predict() method, passing in the new data.
svm = SVC()

#linear': This performs a linear classification in the original input space.
#'rbf' (radial basis function): This is a commonly used kernel that creates non-linear decision boundaries.
#'poly' (polynomial): This allows for learning non-linear decision boundaries by raising the features to certain polynomial powers.
#'sigmoid': This creates an S-shaped decision surface.
#C: This parameter controls the trade-off between the complexity of the model and the training error. A higher C value allows for a less smooth decision surface but reduces the training error. The values in the code are chosen using np.logspace(-3, 3, 5), which creates a logarithmically spaced grid of 5 values between 10^-3 and 10^3. This allows you to try out different regularization strengths.
#gamma: This parameter is specific to the 'rbf' kernel and controls the influence of training data points on the classification. A higher gamma value leads to a more localized decision surface, focusing on nearby training points. Similar to C, the values are chosen using np.logspace(-3, 3, 5) to explore different influences.
parametersSVM = {'kernel':('linear', 'rbf','poly','rbf', 'sigmoid'),
              'C': np.logspace(-3, 3, 5),
              'gamma':np.logspace(-3, 3, 5)}

#The code you provided, svm_cv= GridSearchCV(svm, parametersSVM, cv=10), builds upon the parametersSVM dictionary you defined earlier and uses it to perform a grid search for the best SVM model.
#cv=10: This sets the number of folds for cross-validation to 10. Cross-validation is a technique to evaluate model performance on unseen data. Here, the data will be split into 10 folds, and the model will be trained on 9 folds while evaluated on the remaining 1 fold. This process is repeated 10 times (each fold is used for evaluation once), providing a more robust estimate of model performance.
svm_cv= GridSearchCV(svm, parametersSVM, cv=10)

"""# Calculate the accuracy on the test data using the method score:"""

#This code snippet evaluates the best SVM model found by svm_cv on the unseen test data (X_test, Y_test) and returns a score indicating the model's generalization ability to unseen data. It essentially helps you assess how well the chosen model performs on real-world data it hasn't been trained on.
svm_cv.score(X_test, Y_test)

"""Create a decision tree classifier object then create a GridSearchCV object tree_cv with cv = 10. Fit the object to find the best parameters from the dictionary parameters.

# Decision tree
"""

#This line of code is the first step towards building a decision tree model for classification. The DecisionTreeClassifier object you created (tree) can be further customized with various parameters (like maximum depth, minimum samples per split, etc.) to control the complexity of the decision tree. Once configured, you can train this model on your data using the fit() method and then use it to predict class labels for new unseen data points using the predict() method.
tree = DecisionTreeClassifier()

#criterion: This parameter specifies the function used by the decision tree to select the best feature for splitting a node. The available options are:

#'gini': This is the Gini impurity measure, a common choice that calculates the likelihood of a random sample from a node belonging to the wrong class.
#'entropy': This is the information entropy measure, another popular choice that calculates the disorder or randomness within a node regarding class labels.
#splitter: This parameter determines the strategy for splitting a node during the tree building process. The options are:
#'best': This is the default option that searches for the best splitting feature based on the chosen criterion (gini or entropy).
#'random': This selects a random feature at each split point, introducing some randomness and potentially reducing overfitting.
#max_depth: This parameter controls the maximum depth of the decision tree. A deeper tree can potentially learn more complex patterns but is also more prone to overfitting. The provided values explore depths from 2 to 18 (using list comprehension).
#max_features: This parameter specifies the maximum number of features considered at each split during tree growth. Here, 'auto' selects the number of features equal to the square root of the total number of features, and 'sqrt' explicitly sets it to the square root. Exploring both options allows you to see if limiting features helps.
#min_samples_leaf: This parameter sets the minimum number of samples allowed in a final leaf node. This helps avoid creating overly specific decision trees that may not generalize well. The values here try 1, 2, and 4 minimum samples per leaf.
#min_samples_split: This parameter controls the minimum number of samples required to split an internal node. It helps prevent splitting nodes with too few samples, which could lead to unreliable splits. Here, the code explores minimum split sizes of 2, 5, and 10.
parametersTree = {'criterion': ['gini', 'entropy'],
     'splitter': ['best', 'random'],
     'max_depth': [2*n for n in range(1,10)],
     'max_features': ['auto', 'sqrt'],
     'min_samples_leaf': [1, 2, 4],
     'min_samples_split': [2, 5, 10]}

#This line of code creates an instance of the GridSearchCV class from the sklearn.model_selection library in Python. The GridSearchCV class is used for hyperparameter tuning, which is the process of finding the optimal set of hyperparameters for a machine learning model.
#cv=10: This argument specifies the number of folds to use for cross-validation. Cross-validation is a technique used to evaluate the performance of a model on unseen data. In this case, the training data will be split into 10 folds, and the model will be trained on 9 folds and evaluated on the remaining fold. This process will be repeated 10 times, using a different fold for evaluation each time. The average performance across these 10 folds is used as the model's score for that set of hyperparameters.
tree_cv= GridSearchCV(tree, parametersTree, cv=10)

#Improved Model Performance: By finding the optimal hyperparameters, grid search with cross-validation can help you achieve better performance from your machine learning model.
#Reduced Overfitting: Grid search with cross-validation helps to prevent overfitting, which is the phenomenon where a model performs well on training data but poorly on unseen data.
tree_cv.fit(X_train, Y_train)

print("tuned hpyerparameters :(best parameters) ",tree_cv.best_params_)
print("accuracy :",tree_cv.best_score_)
#criterion='gini': This means the Gini impurity criterion was used for splitting nodes in the decision tree.
#max_depth=8: The maximum depth of the tree is 8, limiting its complexity.
#max_features='sqrt': The square root of the number of features was used for selecting features at each split.
#min_samples_leaf=2: At least 2 samples must be present at each leaf node.
#min_samples_split=10: At least 10 samples are required to split a node.
#splitter='random': The random split strategy was used for selecting features at each split.
#The second line shows the best accuracy score (0.789 in this example) achieved by the model using these hyperparameters.

"""These lines of code effectively print the most valuable results from the hyperparameter tuning process: the optimal hyperparameter configuration and the corresponding model accuracy. This information can be crucial for evaluating the effectiveness of your model and making informed decisions about its deployment.

Calculate the accuracy of tree_cv on the test data using the method score.

# KNN _ k nearest neighbors
"""

#KNN is a non-parametric, supervised learning algorithm used for classification and regression tasks. It works by classifying a new data point based on the labels of its k nearest neighbors in the training data
KNN = KNeighborsClassifier()

#Hyperparameters:

#n_neighbors: This key specifies the number of nearest neighbors to consider for classification. The list of values includes options from 1 to 10, allowing you to explore different neighborhood sizes.
#algorithm: This key defines the algorithm used to search for nearest neighbors. The list includes options:
#'auto': This lets the KNN classifier choose the most suitable algorithm automatically.
#'ball_tree': This is a space partitioning algorithm efficient for high-dimensional data.
#'kd_tree': Another space partitioning algorithm that can be efficient for certain data structures.
#'brute': This is a brute-force search, which is the simplest but computationally expensive for large datasets.
#p: This key controls the distance metric used. The list includes options:
#1: This represents the Manhattan distance.
#2: This represents the Euclidean distance (commonly used by default).
parametersKnn = {'n_neighbors': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
              'algorithm': ['auto', 'ball_tree', 'kd_tree', 'brute'],
              'p': [1,2]}

#Improved Model Performance: By finding the optimal hyperparameters, grid search with cross-validation can help you achieve better performance from your KNN model.
knn_cv= GridSearchCV(KNN, parametersKnn, cv=10)

knn_cv.fit(X_train, Y_train)

print("tuned hpyerparameters :(best parameters) ",knn_cv.best_params_)
print("accuracy :",knn_cv.best_score_)

"""Calculate the accuracy of knn_cv on the test data using the method score:"""

knn_cv.score(X_test, Y_test)

yhatknn = knn_cv.predict(X_test)
plot_confusion_matrix(Y_test,yhatknn)

"""# Find the method performs best:"""

#The code snippet accu=[] and Method=[] in Python creates two empty lists named accu and Method.
accu=[]
Method=[]

#The code you provided demonstrates how to evaluate the performance of different machine learning models and store the results in separate lists.
#This line calculates the accuracy score of a logistic regression model (logreg_cv) on the test data (X_test, Y_test).
#The score method of the logreg_cv object likely evaluates the model's performance using a metric like accuracy (percentage of correct predictions).
#The resulting accuracy score is then appended to the accu list using the append method. This adds the score as a new element at the end of the list.
accu.append(logreg_cv.score(X_test, Y_test))
#This line adds a string label "logestic regression" to the Method list.
This label helps identify which model's accuracy score was stored in the accu list in the previous step.
Method.append('logestic regression')
#-------------------------------------
#The code iterates through different machine learning models represented by objects like logreg_cv, tree_cv, and knn_cv. (The commented-out section suggests there might have been an SVM model as well).
#For each model, it uses the score method to evaluate its performance on the unseen test data (X_test, Y_test).
#The calculated accuracy score is stored in the accu list.
#A corresponding label indicating the model type (e.g., "logistic regression", "Decision Tree") is added to the Method list to keep track of which score belongs to which model.
#accu.append(svm_cv.score(X_test, Y_test))
#Method.append('SVM')
#--------------------------------------
accu.append(tree_cv.score(X_test, Y_test))
Method.append('Decission Tree')
#---------------------------------------
accu.append(knn_cv.score(X_test, Y_test))
Method.append('KNN')

print(accu)  #print(accu): This line prints the list accu containing the accuracy scores for the evaluated models.
print(Method)  #print(Method): This line prints the list Method containing labels that correspond to the models in the accu list. These labels were added earlier to keep track of which accuracy score belongs to which model.

import matplotlib.pyplot as plt

fig= plt.figure(figsize=(10,5))
plt.bar(Method, accu, width=0.3, color='red')
plt.xlabel('Methods')
plt.ylabel('Accuracy')
plt.title('Best Method Performs predict01')
plt.show()
#Overall, this code snippet generates a bar chart that helps you visually compare the accuracy scores of different machine learning models. The x-axis shows the model types, the y-axis shows the accuracy scores, and the bar heights represent the corresponding accuracy values for each model.